#include "Decimal.h"
#include <cmath>


Decimal::Decimal()
{
	num = "0/1";
	type = 'd';
	sign = 1;
};

Decimal::Decimal(const Integer &n, const Integer &d)
{
	if (d.getNum() == "0") throw invalid_argument("Denominator cannot be 0");
	if ((n.sign == 1 && d.sign == 1) || (n.sign == -1 && d.sign == -1))
		sign = 1;
	else sign = -1;
	
	num = n.num + "/" + d.num;
	type = 'd';
}

Decimal::Decimal(int n)
{
	sign = 1;
	if (n < 0)
	{
		sign = -1;
		n *= sign;
	}
	num = to_string(n) + "/1";
	type = 'd';
}

Decimal::Decimal(const char *str)
{
	type = 'd';
	string delimiter = ".";
	string tmp = "";
	string arg = str;
	Integer numerator, denominator;
	if (str[0] == '-')
	{
		num = arg.substr(1, arg.find(delimiter) - 1);
		sign = -1;
	}
	else
	{
		num = arg.substr(0, arg.find(delimiter));
		sign = 1;
	}
	tmp = arg.erase(0, arg.find(delimiter) + delimiter.length());
	
	////Repeating decimal converting
	int Plen = 0, pos_a = 0;
	vector<short> f;
	for (int i = 0; i < tmp.length(); i++)
	{// find pattern and its starting position (KMP algorithm)
		f = FailureFunction(tmp);
		if (f.back() == -1) tmp.erase(0, 1);
		else break;
		++pos_a;
	}
	for (int i = 0; i < f.size(); i++) // find the length of the pattern
		if (f[i] > -1) { Plen = i; break; }
	
	if (Plen) // pattern found
	{
		// cut the number at the end of the first pattern and substract the non repeating part
		tmp = arg.substr(0, pos_a + Plen);
		if (pos_a > 0) numerator = Integer(tmp) - Integer(tmp.substr(0, pos_a));
		else numerator.num = tmp; // there is no non repeating part
		denominator.num = ""; // there is a redundent '0' generated by the constructor
		for (int i = 0; i < tmp.length(); i++)
			denominator.num.push_back((i < Plen)? '9': '0');
	}
	////end of Repeating decimal converting
	else
	{// if the decimal is finite or non repeating
		denominator.num.resize(arg.length(), '0');
		denominator.num = '1' + denominator.num;
		numerator.num	= arg;
	}
	
	// add the integer part to the fraction
	numerator = Integer(num) * denominator + numerator;
	
	num = numerator.num + "/" + denominator.num;
}

Decimal::Decimal(const string &str)
{
	*this = Decimal(str.c_str());
}



Decimal::Decimal(const Integer& n)
{
	num = n.num + "/1";
	type = 'd';
	sign = n.sign;
};

Decimal::~Decimal()
{
	//do nothing
};

void Decimal::Power(const NumberBase &b, int p)
{
	/*
	 Integer *pwr = (Integer*)(&p);
	 for (Integer i("2"); *pwr >= i; i = i + 1)  *this = (*this) * (*this);
	 */
	//return  *this;
};
/*
 NumberBase& Decimal::operator +(const NumberBase & b)
 {
	
	string delimiter = "/";
	string aug = num; //augend
	string add = b.getNum(); //addend
	
	long  x1, x2, y1, y2;
	x1 = x2 = y1 = y2 = 1;
	x1 = atol(aug.substr(0, aug.find(delimiter)).c_str()) * sign;
	x2 = atoi(aug.erase(0, aug.find(delimiter) + delimiter.length()).c_str());
	y1 = atoi(add.substr(0, add.find(delimiter)).c_str()) * b.getSign();
	y2 = atoi(add.erase(0, add.find(delimiter) + delimiter.length()).c_str());
	
	Decimal *res = new Decimal((x1*y2) + (y1*x2), x2 * y2);
	return *res;
 
 };
 */
//NumberBase& Decimal::operator -(const NumberBase & b) {};
//NumberBase& Decimal::operator *(const NumberBase & b) {};
//NumberBase& Decimal::operator /(const NumberBase & b) {};

Decimal& operator +(const Decimal &a, const Decimal &b)
{
	string delimiter = "/";
	string aug = a.num; //augend
	string add = b.num; //addend
	
	long  x1, x2, y1, y2;
	x1 = x2 = y1 = y2 = 1;
	x1 = atol(aug.substr(0, aug.find(delimiter)).c_str()) * a.sign;
	x2 = atoi(aug.erase(0, aug.find(delimiter) + delimiter.length()).c_str());
	y1 = atoi(add.substr(0, add.find(delimiter)).c_str()) * b.sign;
	y2 = atoi(add.erase(0, add.find(delimiter) + delimiter.length()).c_str());
	
	Decimal *res = new Decimal((x1*y2) + (y1*x2), x2 * y2);
	return *res;
}

Decimal& operator -(const Decimal &a, const Decimal &b)
{
	string delimiter = "/";
	string sub = a.num; //subtrahend
	string min = b.num; //minuend
	long  x1, x2, y1, y2;
	x1 = x2 = y1 = y2 = 1;
	x1 = atol(sub.substr(0, sub.find(delimiter)).c_str()) * a.sign;
	x2 = atoi(sub.erase(0, sub.find(delimiter) + delimiter.length()).c_str());
	y1 = atoi(min.substr(0, min.find(delimiter)).c_str()) * b.sign;
	y2 = atoi(min.erase(0, min.find(delimiter) + delimiter.length()).c_str());
	
	Decimal *res = new Decimal((x1*y2) - (y1*x2), x2 * y2);
	return *res;
};

Decimal& operator *(const Decimal &a, const Decimal &b)
{
	string delimiter = "/";
	string mpc = a.num; //Multiplicand
	string mpr = b.num; //Multiplier
	long  x1, x2, y1, y2;
	x1 = x2 = y1 = y2 = 1;
	x1 = atol(mpc.substr(0, mpc.find(delimiter)).c_str()) * a.sign;
	x2 = atoi(mpc.erase(0, mpc.find(delimiter) + delimiter.length()).c_str());
	y1 = atoi(mpr.substr(0, mpr.find(delimiter)).c_str()) * b.sign;
	y2 = atoi(mpr.erase(0, mpr.find(delimiter) + delimiter.length()).c_str());
	
	Decimal *res = new Decimal(x1 * y1, x2 * y2);
	return *res;
};

Decimal& operator /(const Decimal &a, const Decimal &b)
{
	string delimiter = "/";
	string dvd = a.num; //Dividend
	string dvr = b.num; //Divisor
	Integer  x1, x2, y1, y2;
	
	x1 = dvd.substr(0, dvd.find(delimiter));
	x2 = dvd.erase(0, dvd.find(delimiter) + delimiter.length());
	y1 = dvr.substr(0, dvr.find(delimiter));
	y2 = dvr.erase(0, dvr.find(delimiter) + delimiter.length());
	
	Decimal *res = new Decimal(x1 * y2, x2 * y1);
	res->sign = ((a.sign == 1 && b.sign == 1) || (a.sign == -1 && b.sign == -1))? 1 : -1;
	return *res;
};


void Decimal::operator =(const char *str)
{
	Decimal tmp = Decimal(str);
	num = tmp.num;
	type = tmp.type;
	sign = tmp.sign;
}

istream& Decimal::input(istream &is)
{
	string input = "";
	is >> input;
	*this = Decimal(input);
	return is;
}

ostream& Decimal::output(ostream &os) const
{
	string str = Divide(*this, 100);
	if (sign < 0) str = "-" + str;
	// word wrapper
	/*
	 for (size_t i = 1, delimiter = 60; i <= (str.length() / 60); i++, delimiter++)
	 {
		str.insert(delimiter, 1, '\n');
		delimiter += 60;
	 }
	 */
	os << str;
	return os;
}

string Decimal::Divide(const Decimal &n, int dp)
{
	string tmp = n.num;
	string delimiter = "/";
	string numerator = tmp.substr(0, tmp.find(delimiter));
	string denominator = tmp.erase(0, tmp.find(delimiter) + delimiter.length());
	
	string quotient("");
	Integer dividend;
	Integer divisor(denominator);
	
	size_t decimal_place = 0;
	// icreases decimal_place every time an extra 0 is being appended
	dividend.num = ""; // clear the default '0'
	dividend.num.push_back(numerator[0]); // push in the first digit of numerator
	numerator.erase(0, 1); // erase it from numerator
	while (decimal_place <= dp)
	{
		if (dividend >= divisor)
		{
			/////////////////// DIVIDE ////////////////////
			for (int i = 1; i <= 10; i++)
			{
				if (dividend >= (divisor * i)) // finding the quotient
					continue;
				else
				{
					dividend = dividend - (divisor * (i - 1)); // subtraction
					quotient.push_back(i - 1 + '0'); // pushing the result into quotient
					break;
				}
			}/// end of DIVIDE
		}
		else quotient.push_back('0'); // the dividend is not big enough to be divided
		
		if (dividend.num == "0") dividend.num = ""; // the last substraction leaves no remainder
		
		if (numerator == "") // no more digit left from the original numerator
		{
			if (!decimal_place) quotient.push_back('.'); // placeing decimal point if it hasn't been done
			if (dividend.num != "") dividend.num.push_back('0'); // appending extra '0', allowing the division to proceed
			else { quotient.pop_back(); break; } // divided evenly
			++decimal_place; // marking down current decimal place
		}
		else
		{// appending next digit from numerator to dividend
			dividend.num.push_back(numerator[0]);
			numerator.erase(0, 1);
		}
	}
	while (quotient[0] == '0' && quotient[1] != '.')
	{// removing leading '0's
		quotient.erase(0, 1);
	}
	return quotient;
}



vector<short> Decimal::FailureFunction(const string &p)
{
	vector<short> failure;
	failure.resize(p.size(), 0);
	// iterative, bottom-up DP
	for (int i = 1, j = failure[0] = -1; i < p.size(); ++i)
	{
		// 先試 p[0...i-1] 的「次長的相同前綴後綴」，
		// 也就是 p[0...failure[i-1]] = p[0...j]。
		// 再試 p[0...j] 的「次長的相同前綴後綴」，
		// 也就是 p[0...failure[j]]。
		// 再試 p[0...failure[j]] 的「次長的相同前綴後綴」……
		// 直到試成功為止。
		while (j >= 0 && p[j+1] != p[i])
			j = failure[j];
		
		// p[i] 終於有用處了，終於可以加長！
		if (p[j+1] == p[i]) j++;
		
		// 得到了 failure[i] 的值！
		failure[i] = j;
	}
	return failure;
}

