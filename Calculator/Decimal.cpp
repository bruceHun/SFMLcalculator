#include "Decimal.h"
#include <cmath>


Decimal::Decimal() 
{
	num = "0/1";
	type = 'd';
	sign = 1;
};

Decimal::Decimal(const Integer &n, const Integer &d)
{
	if ((n.sign == 1 && d.sign == 1) || (n.sign == -1 && d.sign == -1))
		sign = 1;
	else sign = -1;
	
	num = n.num + "/" + d.num;
	type = 'd';
}

Decimal::Decimal(int n)
{
	sign = 1;
	if (n < 0)
	{
		sign = -1;
		n *= sign;
	}
	num = to_string(n) + "/1";
	type = 'd';
}

Decimal::Decimal(const char *str)
{
	type = 'd';
	string delimiter = ".";
	string tmp = "";
	string arg = str;
	Integer numerator, denominator;
	if (str[0] == '-')
	{
		num = arg.substr(1, arg.find(delimiter));
		sign = -1;
	}
	else
	{
		num = arg.substr(0, arg.find(delimiter));
		sign = 1;
	}
	tmp = arg.erase(0, arg.find(delimiter) + delimiter.length());

	////Repeating decimal converting
	int Plen = 0, pos_a = 0;
	vector<short> f;
	for (int i = 0; i < tmp.length(); i++)
	{// find pattern and its starting position (KMP algorithm)
		f = FailureFunction(tmp);
		if (f.back() == -1) tmp.erase(0, 1);
		else break;
		++pos_a;
	}
	for (int i = 0; i < f.size(); i++) // find the length of the pattern
		if (f[i] > -1) { Plen = i; break; }
	
	if (Plen) // pattern found
	{
		// cut the number at the end of the first pattern and substract the non repeating part
		tmp = arg.substr(0, pos_a + Plen);
		if (pos_a > 0) numerator = Integer(tmp) - Integer(tmp.substr(0, pos_a));
		else numerator.num = tmp; // there is no non repeating part
		denominator.num = ""; // there is a redundent '0' generated by the constructor
		for (int i = 0; i < tmp.length(); i++)
			denominator.num.push_back((i < Plen)? '9': '0');
	}
	////end of Repeating decimal converting
	else
	{// if the decimal is finite or non repeating
		denominator.num.resize(arg.length(), '0');
		denominator.num = '1' + denominator.num;
		numerator.num	= arg;
	}
	
	// add the integer part to the fraction
	numerator = Integer(num) * denominator + numerator;
	
	num = numerator.num + "/" + denominator.num;
}

Decimal::Decimal(const string &str)
{
	*this = Decimal(str.c_str());
}



Decimal::Decimal(const Integer& n)
{
	num = n.num + "/1";
	type = 'd';
	sign = n.sign;
};

Decimal::~Decimal() 
{
	//do nothing
};

NumberBase& Decimal::Pwr(const NumberBase &p)
{
	Integer *pwr = (Integer*)(&p);
	for (Integer i("2"); *pwr >= i; i = i + 1)  *this = (*this) * (*this);
	return  *this;
};
/*
NumberBase& Decimal::operator +(const NumberBase & b)
{
	
	string delimiter = "/";
	string aug = num; //augend
	string add = b.getNum(); //addend
	
	long  x1, x2, y1, y2;
	x1 = x2 = y1 = y2 = 1;
	x1 = atol(aug.substr(0, aug.find(delimiter)).c_str()) * sign;
	x2 = atoi(aug.erase(0, aug.find(delimiter) + delimiter.length()).c_str());
	y1 = atoi(add.substr(0, add.find(delimiter)).c_str()) * b.getSign();
	y2 = atoi(add.erase(0, add.find(delimiter) + delimiter.length()).c_str());
	
	Decimal *res = new Decimal((x1*y2) + (y1*x2), x2 * y2);
	return *res;
	 
};
 */
//NumberBase& Decimal::operator -(const NumberBase & b) {};
//NumberBase& Decimal::operator *(const NumberBase & b) {};
//NumberBase& Decimal::operator /(const NumberBase & b) {};

Decimal& operator +(const Decimal &a, const Decimal &b)
{
	string delimiter = "/";
	string aug = a.num; //augend
	string add = b.num; //addend

	long  x1, x2, y1, y2;
	x1 = x2 = y1 = y2 = 1;
	x1 = atol(aug.substr(0, aug.find(delimiter)).c_str()) * a.sign;
	x2 = atoi(aug.erase(0, aug.find(delimiter) + delimiter.length()).c_str());
	y1 = atoi(add.substr(0, add.find(delimiter)).c_str()) * b.sign;
	y2 = atoi(add.erase(0, add.find(delimiter) + delimiter.length()).c_str());

	Decimal *res = new Decimal((x1*y2) + (y1*x2), x2 * y2);
	return *res;
}

Decimal& operator -(const Decimal &a, const Decimal &b) 
{
	string delimiter = "/";
	string sub = a.num; //subtrahend		
	string min = b.num; //minuend
	long  x1, x2, y1, y2;
	x1 = x2 = y1 = y2 = 1;
	x1 = atol(sub.substr(0, sub.find(delimiter)).c_str()) * a.sign;
	x2 = atoi(sub.erase(0, sub.find(delimiter) + delimiter.length()).c_str());
	y1 = atoi(min.substr(0, min.find(delimiter)).c_str()) * b.sign;
	y2 = atoi(min.erase(0, min.find(delimiter) + delimiter.length()).c_str());

	Decimal *res = new Decimal((x1*y2) - (y1*x2), x2 * y2);
	return *res;
};

Decimal& operator *(const Decimal &a, const Decimal &b)
{
	string delimiter = "/";
	string mpc = a.num; //Multiplicand	
	string mpr = b.num; //Multiplier
	long  x1, x2, y1, y2;
	x1 = x2 = y1 = y2 = 1;
	x1 = atol(mpc.substr(0, mpc.find(delimiter)).c_str()) * a.sign;
	x2 = atoi(mpc.erase(0, mpc.find(delimiter) + delimiter.length()).c_str());
	y1 = atoi(mpr.substr(0, mpr.find(delimiter)).c_str()) * b.sign;
	y2 = atoi(mpr.erase(0, mpr.find(delimiter) + delimiter.length()).c_str());

	Decimal *res = new Decimal(x1 * y1, x2 * y2);
	return *res;
};

Decimal& operator /(const Decimal &a, const Decimal &b)
{
	string delimiter = "/";
	string dvd = a.num; //Dividend
	string dvr = b.num; //Divisor
	Integer  x1, x2, y1, y2;
	
	x1 = dvd.substr(0, dvd.find(delimiter));
	x2 = dvd.erase(0, dvd.find(delimiter) + delimiter.length());
	y1 = dvr.substr(0, dvr.find(delimiter));
	y2 = dvr.erase(0, dvr.find(delimiter) + delimiter.length());

	Decimal *res = new Decimal(x1 * y2, x2 * y1);
	res->sign = ((a.sign == 1 && b.sign == 1) || (a.sign == -1 && b.sign == -1))? 1 : -1;
	return *res;
};


void Decimal::operator =(const char *str)
{
	Decimal tmp = Decimal(str);
	num = tmp.num;
	type = tmp.type;
	sign = tmp.sign;
}

ostream& Decimal::output(ostream &os) const
{
	string tmp = num;
	string delimiter = "/";
	string numerator = tmp.substr(0, tmp.find(delimiter));
	string denominator = tmp.erase(0, tmp.find(delimiter) + delimiter.length());

	Integer quotient("");
	Integer dividend(numerator);
	Integer divisor(denominator);
	
	size_t lenA = numerator.length() , lenB = denominator.length();

	size_t decimal_place = 0, pos = 0;
	// icreases decimal_place every time an extra 0 is being appended
	// pos stands for the position of the decimal point

	if (denominator == "1")
	{
		quotient = numerator;
		os << ((sign < 0)?"-":"") << quotient;
		return os;
	}
	
	while (lenA < lenB)
	{// not enough digits to begin with
		if (!decimal_place) pos++;
		quotient.num.push_back('0');
		numerator.push_back('0');
		++decimal_place;
		++lenA;
	}

	while (decimal_place < 100)
	{// long division to 100 decimal places
		if (numerator == "")
		{// no remainder
			quotient.num.push_back('0');
			++decimal_place;
			continue;
		}
		else if (numerator[0] == '0')
		{// remaining 0 from dividend exist when the previous division generates no remainder
			if (numerator.length() == 1) { numerator = "";  continue; }
			quotient.num.push_back('0');
			numerator.erase(0, 1);
			++pos;
			--lenA;
			continue;
		}

		while (1)
		{// dividend finding loop
			while (lenA < lenB)
			{// not enough digits to be divide
				numerator.push_back('0');
				++decimal_place;
				++lenA;
			}

			if (lenA > lenB)
			{// ordinary situation
				dividend = numerator.substr(0, lenB);
				numerator.erase(0, lenB);
				if (divisor > dividend)
				{// add one more digit when divisor is bigger than dividend
					dividend.num.push_back(numerator.front());
					numerator.erase(0, 1);
				}
				lenA = numerator.length();
				break;
			}
			else if (lenA == lenB)
			{// same amount of digits
				dividend = numerator;
				numerator = ""; lenA = 0;
				if (divisor > dividend)
				{// add an extra 0 when divisor is bigger than dividend
					dividend.num.push_back('0');
					++decimal_place;
				}
				break;
			}

		}// end of while (dividend finding loop)

		 /////////////////// DIVIDE ////////////////////
		for (int i = 1; i <= 10; i++)
		{
			if (dividend >= (divisor * i)) // fing the quotient
				continue;
			else
			{
				dividend = dividend - (divisor * (i - 1)); // substraction
				//if (dividend.num == "0") // no remainder
					//dividend.num = "";
					
				numerator = dividend.num + numerator; // the number left to be divided
			
				lenA = numerator.length();
				quotient.num.push_back(i - 1 + '0');
				if (!decimal_place) pos++; // marking down the position of the decimal point
				break;
			}
		}
	}// end of while (long division to 100 decimal places)

	if (pos)
		quotient.num.insert(pos, ".");
	else
		quotient.num.insert(0, "0.");
	
	// word wrapper
	for (size_t i = 1, delimiter = 60; i <= (quotient.num.length() / 60); i++, delimiter++)
	{
		quotient.num.insert(delimiter, 1, '\n');
		delimiter += 60;
	}

	os << ((sign < 0)?"-":"") << quotient;
	return os;
}


vector<short> Decimal::FailureFunction(const string &p)
{
	vector<short> failure;
	failure.resize(p.size(), 0);
	// iterative, bottom-up DP
	for (int i = 1, j = failure[0] = -1; i < p.size(); ++i)
	{
		// 先試 p[0...i-1] 的「次長的相同前綴後綴」，
		// 也就是 p[0...failure[i-1]] = p[0...j]。
		// 再試 p[0...j] 的「次長的相同前綴後綴」，
		// 也就是 p[0...failure[j]]。
		// 再試 p[0...failure[j]] 的「次長的相同前綴後綴」……
		// 直到試成功為止。
		while (j >= 0 && p[j+1] != p[i])
			j = failure[j];
		
		// p[i] 終於有用處了，終於可以加長！
		if (p[j+1] == p[i]) j++;
		
		// 得到了 failure[i] 的值！
		failure[i] = j;
	}
	return failure;
}

